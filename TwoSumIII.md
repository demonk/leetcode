### 653. Two Sum IV - Input is a BST

事实上考虑这个问题有两个角度
- 要找到的是一个和
- 要找到的是一个差

找到一个和，是正面的想法，如何从一个BST中，找到两个值，其和等于目标值;

开始的时候被BST迷惑了，因为我知道这个问题其中是跟***#167. Two Sum II - Input array is sorted*** 是一致的，只是这个是伪装成一个BST而已。要知道，BST本身也是有序的，只不过有序是隐藏在了一棵树当中。

开始的时候我的思路是这样了的，

既然是一棵有序树，那我以根为中心，逐一与左右子树的结点相加，看是否与目标值相等；
***如果左子树里的最大和也小于目标值，那就可以不需要考虑左子树了***

但事实上我有点SB了，题目要求的是相加的值，而不是范围，树中最小的值（最左结点）与最大的值（最右结点）相加同样也有可能得到目标值。

所以，无论我怎么想着去在树查询遍历上去做优化，得到的都是不能完全覆盖用例的代码。

到最后，还是要沦落到要使用遍历排序，再使用#167的办法来解决。

由于使用的是C，还需要预先申请一个大数组，这点确实不爽。

但也可以反过来想，需要找到一个差，并查找这个差是否在BST当中，如果存在，则认为结果成立。
这就需要一个hashset就可以了。
